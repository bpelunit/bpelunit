 In diesem Abschnitt werden die Metriken für die Messung der Testabdeckung in BPEL definiert. Dabei werden die in ... beschrieben Abdeckungsmetriken an BPEL-Kontext angepasst und neue spezifische Metriken eingeführt. Anschließend wird auf der Instrumentierung basierende Umsetzung vorgestellt.

  \subsection{Statementabdeckung}
  Mit BPEL lässt sich ein Prozess beschreiben, der in der Lage ist, verschiedene Dienste (Web SerServices) zu einer Gesamtanwendung zu verknüpfen. Die Kommunikation mit den Diensten wird in BPEL durch Basisaktivitäten realisiert. Die Basisaktivitäten sind die elementaren Aktivitäten eines Prozesses, die keine weiteren Aktivitäten enthalten. Es muss beim Testen zu mindestens sichergestellt werden, dass alle Basisaktivitäten durch die Tests abgedeckt sind. 
  
  Insbesondere ist diese Statistik im Bezug auf einzelne Aktivitäten interessant. So ist die Information, ob alle \textit{invoke}-Aktivitäten (Web Service-Aufrufe) beim Testen ausgeführt wurden, sehr wichtig, um die erste Einschätzung über die Testqualität zu machen. In dieser Hinsicht ist die Definition der Abdeckungsmetriken für die einzelnen Basisaktivitäten sinnvoll. Die Statementabdeckung\footnote{Die Aktivitäten in BPEL entsprechen den Statements in anderen Programmiersprachen.} für die \textit{invoke}-Aktivitäten wird wie folgt definiert: 
 \[
	Statementabdeckung_{invoke}=\frac{\text{Anzahl der ausgeführten \textit{invoke}-Aktivitäten}}{\text{Anzahl der \textit{invoke}-Aktivitäten}}
\]
Entsprechend sind die Abdeckungsmetriken der anderen Basisaktivitäten definiert.  

Die gesamte Statementabdeckung wird in dieser Arbeit auf die Messung der Basisaktivitäten eingeschränkt:  
\[
	Statementabdeckung=\frac{\text{Anzahl der ausgeführten Basisaktivitäten}}{\text{Anzahl der Basisaktivitäten}}
\] 

Die  Abdeckung der strukturierten Aktivitäten, die den Kontrollfluss des BPEL-Prozesses definieren, wird im Zusammenhang mit der Zweigabdeckung in folgenden Abschnitten behandelt.

Die Information über tatsächliche Ausführung der Aktivitäten hat einen Mehrwert gegenüber der Information, dass eine Aktivität zur Ausführung stimuliert wurde (aber evtl. nicht erfolgreich ausgeführt werden konnte). Deswegen erfolgt das Logging jeweils \textit{nach} der Ausführung der entsprechenden Aktivität.  Die Aktivitäten, die den normalen Kontrollfluss ändern, können allerdings auf diese Weise nicht bzw. nur sehr umständlich registriert werden:  
\begin{itemize}
	\item \textit{throw}
	\item \textit{rethrow}
	\item \textit{compensate}
	\item \textit{compensateScope}
	\item \textit{exit}
\end{itemize}
\textit{Exit} beendet den Prozess und kann logischerweise nur vor der Ausführung erfasst werden. Die \textit{throw-}, \textit{rethrow-}, \textit{compensate-} und \textit{compensateScope-}Aktivitäten unterbrechen den normalen Kontrollfluss und veranlassen die Ausführung der entsprechenden Handler. Obwohl die tatsächliche Ausführung dieser Aktivitäten in diesen Händlern registriert werden könnte, wurde auf Grund eines großen zusätzlichen Aufwands und dazu verhältnismäßig kleines Informationsgewinns entschieden, darauf zu verzichten und die Aktivitäten, wie bei \textit{Exit}, vor der Ausführung zu loggen. 
Aus diesem Grund werden die entsprechenden Aktivitäten auch dann geloggt (als ausgeführt markiert), wenn bei der Ausführung ein Fehler auftreten sollte.

Die Statementabdeckung ist ein schwaches Kriterium, weil dabei nur die einzelnen Anweisungen betrachtet, ohne Zusammenhänge zu berücksichtigen. 

\subsection{Zweigabdeckung}
Die Definition der Zweigabdeckung aus dem Abschnitt ... wird für BPEL übernommen. Der Kontrollflussgraph muss dagegen an BPEL angepasst werden.
\subsubsection{Normaler Kontrollfluss}
Den Kontrollfluss bestimmen in BPEL, wie bereits mehrmals erwähnt, die strukturierten Aktivitäten. In den folgenden Bildern sind die entsprechenden Kontrollflussgraphen abgebildet. Die grauen Pfeilen deuten an, wie die einzelnen Graphen in den Gesamtfluss eingebunden werden. Für die Zweigabdeckung relevanten Pfeile sind schwarz dargestellt.
\begin{figure}[htbp!]
	\centering
		\includegraphics[width=0.8\textwidth]{bilder/h1.png}
	\label{fig:h1}
\end{figure}
\begin{figure}[htbp!]
	\centering
		\includegraphics[width=0.8\textwidth]{bilder/h2.png}
	\label{fig:h2}
\end{figure}

Bei den vorgestellten Aktivitäten entspricht der Kontrollfluss den Konstrukten, die aus vielen Programmiersprachen bekannt sind. Die Restlichen sind BPEL-spezifisch und müssen gesondert betrachtet werden.

\textbf{\textit{Pick}-Aktivität.}
\parpic[r]{\includegraphics[width=0.70\textwidth]{bilder/pick.png}}
  Bei dieser strukturierenden Aktivität wird ein Zweig aus mehreren anhand eines Ereignisses (Nachricht oder Alarm) ausgewählt. Wurde ein zutreffendes Ereignis empfangen, so wird die zugehörige Aktivität ausgeführt und alle nachfolgenden Ereignisse verworfen. Aus der Sicht des Kontrollflusses stimmt dieses Verhalten mit dem einer IF-Aktivität überein.
  
\textbf{\textit{Flow}-Aktivität.}\\
  Mit der Flow-Aktivität wird in BPEL paralleler Ablauf mehrerer Aktivitäten realisiert. Außerdem gibt es mit dem Link-Konzept, ein mächtiges Instrument, das ermöglicht, komplexe Abläufe zu realisieren. In der Abbildung ... sieht man den zugehörigen Kontrollfluss. 
  Die Links (gestrichelte Pfeile) unterscheiden sich semantisch von den normalen Kanten des Kontrollflussgraphes.
  Wie es bereits im Abschnitt .. geschildert wurde, haben die Links trotzdem einen erheblichen Einfluss auf den Kontrollfluss und sind damit für die Zweigabdeckung relevant. 
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.70\textwidth]{bilder/flow.png}
	\label{fig:flow}
\end{figure}

  Aus der Sicht der Abdeckungsmessung ist die Tatsache besonders, dass der Status der Links drei Werte annehmen kann: \textit{true}, \textit{false} und \textit{unset}  Die normalen Kontrollflusskanten können dagegen nur zwei Werte annehmen: entweder \textit{aktiviert} oder \textit{nicht aktiviert}(\textit{unset}). Für die Links bedeutet das, dass \textit{true}- und \textit{false}-Status bei der Messung der Abdeckung erfasst werden müssen. 

\textbf{\textit{ForEach}-Aktivität.}
Die \textit{ForEach}-Aktivität sorgt für mehrmaliges Ausführen des enthaltenen Scopes. Die Anzahl der Ausführungen wird durch Start- und Stopvariablen vorgegeben. Die Besonderheit dabei ist, dass die Ausführung entweder sequenziell oder parallel erfolgen kann. Die Ausführungsart wird durch den  Wert der Variable \textit{parallel} (\textit{yes}/\textit{no}) geregelt. 

Dieses Verhalten kann durch zwei Graphen dargestellt werden. Die Abbildung ... repräsentiert sequentielle Ausführung, die einer for-Schleife aus den konventionellen Programmiersprachen entspricht. Der Graph daneben repräsentiert eine parallele Ausführung.  \\

Während der reguläre Kontrollfluss des Programms den Steuerfluss für alle reguläre Situationen vorgibt, gibt es in BPEL ein (\textit{FaultHandler})-Kontrollfluss, der für die Behandlung zur Laufzeit aufgetretener Fehler vorgesehen ist. Inwiefern dieses Verhalten in die Zweigabdeckung mit einfließen kann, wird im nächsten Abschnitt diskutiert. 

\subsubsection{Kontrollfluss bei Ausnahmebehandlung}
BPEL-Sprache hat wie viele moderne Programmiersprachen ein Konzept zur strukturierten Behandlung von Laufzeitfehlern. 
Die Umschaltung von normalen auf \textit{FaultHandler-}Kontrollfluss erfolgt automatisch beim Auftreten eines Fehlers. Was programmtechnisch nichts anderes heisst, als dass der zugehörige FaultHandler ausgeführt wird. Die Fehler können auch in den Compensation und in den FaultHandler selbst auftreten. In die Abbildung ... wird der Zusammenhang zwischen Handler und Scopes graphisch dargestellt und durch die Pfeile den möglichen Kontrollfluss zwischen diesen Einheiten gezeigt. 

Vor allem die vielfältige Fehlerquellen und die Möglichkeit die Fehler weiterzuleiten machen es schwierig alle möglichen Übergaben der Aus\-füh\-rungs\-kon\-tro\-lle an die FaultHandler zu berücksichtigen. Aus diesem Grund werden die Verbindungskanten zwischen den Scopes, Fault und Compensation Handler in dieser Arbeit bei der Zweigabdeckung nicht berücksichtigt. 

Das Gleiche gilt für CompemsationHandler, die nur im Rahmen der Fehlerbehandlung ausgeführt werden.

\begin{figure}
	\centering
		\includegraphics{bilder/ScopeFaultCompensation2.png}
	\label{fig:ScopeFaultCompensation2}
\end{figure}

Dass die Fault- und Compensation Handler, sowie die interne Logik dieser Handler, trotzdem durch die Tests abgedeckt werden sollten, ist unumstritten. Demzufolge ist es sinnvoll den Kontrollfluss \textit{innerhalb} der Handler bei der Messung der Abdeckung zu berücksichtigen. In der Abbildung .. wird der Kontrollfluss des gesamten Prozesses angedeutet. Die rote Farbe markiert den aktuellen Durchlauf. Während alle durchgezogenen Pfeile für die Zweigabdeckung relevant sind, gehen die gestrichelten Pfeile, wie bereits erläutert, nicht in die Rechnung ein.  
\begin{figure}
	\centering
		\includegraphics{bilder/ScopeFaultCompensationGross.png}
	\label{fig:ScopeFaultCompensationGross}
\end{figure} 

 
 In den folgenden Abschnitten werden die Metriken vorgestellt, die den Grad der durch die Tests abgedeckten Fault- bzw. Compensation Handler wiedergeben.
\subsection{Fault und Compensation Handler Abdeckung}
Da die Geschäftsprozesse in der Regel langlebig sind und darüber hinaus sensitive
Daten verarbeiten können, ist eine ausreichende Fehlerbehandlung zwingend notwendig.
Im Rahmen einer Fehlerbehandlung ist oft das Zurücksetzen vorangegangener Änderungen erwünscht. Dafür sind CompensationHandler vorgesehen, die das Rückgängig-machen von eigentlich in sich erfolgreichen Aktionen übernimmt.

Aufgrund dieser besonderen Wichtigkeit der Fehlerbehandlung muss das Verhalten des Systems im Fehlerfall umfassend getestet werden. Die in diesem Abschnitt vorgestellten Metriken können dabei als Indikator für die Testqualität bezüglich der Fehlerbehandlung und Kompensation dienen.
 
\textbf{FaultHandler.}
Eine wichtige Information ist zum Beispiel, ob alle durch den Programmierer vogesehen Fehlerbehandlungen in Form von \textit{catch}- bzw \textit{catchAll}-Blöcken durch die Tests stimuliert werden. 
Die folgende Definition legt die dazugehörige Metrik fest: 
\[
	FaultHandlerAbdeckung=\frac{\text{Anzahl der getesten catch- und catchAll-Blöcken }}{\text{Anzahl der catch- und catchAll-Blöcken}}
\]

Die impliziten \textit{FaultHandler} werden nicht berücksichtigt. Die sogenannten \textit{Inline-FaultHandler}, die direkt in die \textit{invok}e-Aktivitäten integriert sind, müssen dagegen in die Berechnung einfließen.

\textbf{Compensation Handler.}
Diese Metrik gibt den Abdeckungsgrad der \textit{CompensationHandler} an: 
\[
	CompensateHandlerAbdeckung=\frac{\text{\textit{Anzahl der getesten Compensation Handler}}}{\text{\textit{Anzahl der Compensation Handler}}}
\]
Die \textit{Inline-CompensateHandler} werden ebenfalls berücksichtigt. \\
\\
\\
